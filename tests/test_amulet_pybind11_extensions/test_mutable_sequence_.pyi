from __future__ import annotations

import collections.abc
import typing

__all__: list[str] = ["TestMutableSequence", "get_mutable_sequence"]

class TestMutableSequence:
    def __contains__(self, item: typing.Any) -> bool: ...
    def __delitem__(self, arg0: typing.SupportsInt) -> None: ...
    @typing.overload
    def __getitem__(self, arg0: typing.SupportsInt) -> int: ...
    @typing.overload
    def __getitem__(self, item: slice) -> list[int]: ...
    def __iadd__(
        self, values: collections.abc.Iterable[typing.SupportsInt]
    ) -> typing.Any: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: collections.abc.Sequence[typing.SupportsInt]) -> None: ...
    def __iter__(self) -> collections.abc.Iterator[int]: ...
    def __len__(self) -> int: ...
    def __reversed__(self) -> collections.abc.Iterator[int]: ...
    def __setitem__(
        self, arg0: typing.SupportsInt, arg1: typing.SupportsInt
    ) -> None: ...
    def append(self, value: typing.SupportsInt) -> None: ...
    def clear(self) -> None: ...
    def count(self, value: typing.SupportsInt) -> int: ...
    def extend(self, values: collections.abc.Iterable[typing.SupportsInt]) -> None: ...
    def index(
        self,
        value: typing.SupportsInt,
        start: typing.SupportsInt = 0,
        stop: typing.SupportsInt = 9223372036854775807,
    ) -> int: ...
    def insert(self, arg0: typing.SupportsInt, arg1: typing.SupportsInt) -> None: ...
    def pop(self, index: typing.SupportsInt = -1) -> typing.Any: ...
    def remove(self, value: typing.SupportsInt) -> None: ...
    def reverse(self) -> None: ...

def get_mutable_sequence() -> collections.abc.MutableSequence[int]: ...
